searchState.loadedDescShard("lexical_util", 0, "Shared utilities for lexical conversion routines.\nSimple, shared algorithms for slices and iterators.\nUtilities for working with ASCII characters.\nDebugging assertions to check a radix is valid.\nPre-defined constants for numeric types.\nUtilities to process digits.\nOptimized division algorithms for u128.\nError type for numeric parsing functions.\nExtended precision floating-point type.\nPublic API for the number format packed struct.\nDefine <code>FromLexical</code> trait.\nDefine <code>FromLexicalWithOptions</code> trait.\nSpecialized iterator traits.\nFast multiplication routines.\nUtilities for Rust numbers.\nShared traits for the options API.\nResult type for numeric parsing functions.\nThe maximum digits that can be held in a u64 for a given …\nDefine <code>ToLexical</code> trait.\nDefine <code>ToLexicalWithOptions</code> trait.\nCheck to see if parsing the float cannot possible overflow.\nCopy bytes from source to destination.\nCount the number of leading characters equal to a given …\nCount the number of trailing characters equal to a given …\nDetermine if a character is a valid ASCII character for …\nDetermine if a slice is all valid ASCII characters for …\nDetermine if a character is a valid ASCII letter.\nDetermine if a slice is all valid ASCII letters. Modified …\nAssertion the buffer has sufficient room for the output.\nCheck radix is in range <code>[2, 36]</code> in debug builds.\nMaximum number of bytes required to serialize any number …\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nDetermine if a character is a digit.\nDetermine if a character is a digit with a radix known at …\nConvert a character to a digit.\nConvert a character to a digit with a radix known at …\nUnchecked, highly optimized algorithm to convert a char to …\nConvert a digit to a character. This uses a pre-computed …\nConvert a digit to a character with a radix known at …\nFast division/remainder algorithm for u128, without a fast …\nFast division/remainder algorithm for u128, without a fast …\nCalculate a div/remainder algorithm optimized for …\nOptimized fallback division/remainder algorithm for u128.\nCalculate the div/remainder of a value based on the radix.\nEmpty byte array found.\nEmpty exponent found.\nEmpty fraction found.\nEmpty integer found.\nEmpty mantissa found.\nError code during parsing, indicating failure type.\nExponent was present without fraction component.\nShort infinity string is too long.\nLong infinity string is too long.\nLong infinity string is too short: it must be as long as …\nInvalid character for a base prefix.\nInvalid character for a base suffix.\nInvalid consecutive exponent digit separator.\nInvalid consecutive fraction digit separator.\nInvalid consecutive integer digit separator.\nInvalid decimal point character.\nInvalid digit found before string termination.\nInvalid digit separator character.\nExponent was present but not allowed.\nInvalid base for the exponent.\nOptional exponent flags were set while disabling exponent …\nInvalid radix for the exponent digits.\nSet no positive exponent sign while requiring exponent …\nInvalid symbol to represent exponent notation.\nInvalid flags were set without the format feature.\nInvalid float parsing algorithm.\nInvalid precision flags for writing floats.\nInvalid short infinity string: must start with an <code>i</code> …\nInvalid long infinity string: must start with an <code>i</code> …\nInteger or integer component of float had invalid leading …\nInvalid radix for the mantissa (significant) digits.\nSet no positive mantissa sign while requiring mantissa …\nInvalid NaN string: must start with an <code>n</code> character.\nInvalid negative exponent break: break is above 0.\nInvalid negative sign for an unsigned type was found.\nInvalid positive exponent break: break is below 0.\nInvalid positive exponent sign was found.\nInvalid positive mantissa sign was found.\nInvalid positive sign for an integer was found.\nInvalid punctuation characters: multiple symbols overlap.\nInvalid radix for the significant digits.\nSet optional special float flags while disable special …\nNo exponent with required exponent notation.\nExponent sign was required(usize), but not found.\nMantissa sign was required(usize), but not found.\nIntegral sign was required(usize), but not found.\nNaN string is too long.\nIntegral overflow occurred during numeric parsing.\nAn error did not actually occur, and the result was …\nIntegral underflow occurred during numeric parsing.\nReturns the argument unchanged.\nGet the index for the parsing error.\nCalls <code>U::from(self)</code>.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nExtended precision floating-point type.\nBinary exponent for the extended-precision float.\nGet the exponent component.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMantissa for the extended-precision float.\nGet the mantissa component.\nMask to extract the base prefix character.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nShift to convert to and from a base suffix as a <code>u8</code>.\nNumber format for a <code>C11</code> literal hexadecimal floating-point …\nNumber format for a <code>C11</code> string hexadecimal floating-point …\nNumber format for a <code>C11</code> literal floating-point number.\nNumber format for a <code>C11</code> string floating-point number.\nNumber format for a <code>C18</code> literal hexadecimal floating-point …\nNumber format for a <code>C18</code> string hexadecimal floating-point …\nNumber format for a <code>C18</code> literal floating-point number.\nNumber format for a <code>C18</code> string floating-point number.\nNumber format for a <code>C89</code> string hexadecimal floating-point …\nNumber format for a <code>C89</code> literal floating-point number.\nNumber format for a <code>C89</code> string floating-point number.\nNumber format for a <code>C90</code> string hexadecimal floating-point …\nNumber format for a <code>C90</code> literal floating-point number.\nNumber format for a <code>C90</code> string floating-point number.\nNumber format for a <code>C99</code> literal hexadecimal floating-point …\nNumber format for a <code>C99</code> string hexadecimal floating-point …\nNumber format for a <code>C99</code> literal floating-point number.\nNumber format for a <code>C99</code> string floating-point number.\nBase prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nExponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nNumber format for a <code>Clojure</code> literal floating-point number.\nNumber format to parse a <code>Clojure</code> float from string.\nNumber format for a <code>Cobol</code> literal floating-point number.\nNumber format to parse a <code>Cobol</code> float from string.\nNumber format for a <code>Coffeescript</code> literal floating-point …\nNumber format to parse a <code>Coffeescript</code> float from string.\nMultiple consecutive digit separators are allowed.\nNumber format for a <code>C#1</code> literal floating-point number.\nNumber format to parse a <code>C#1</code> float from string.\nNumber format for a <code>C#2</code> literal floating-point number.\nNumber format to parse a <code>C#2</code> float from string.\nNumber format for a <code>C#3</code> literal floating-point number.\nNumber format to parse a <code>C#3</code> float from string.\nNumber format for a <code>C#4</code> literal floating-point number.\nNumber format to parse a <code>C#4</code> float from string.\nNumber format for a <code>C#5</code> literal floating-point number.\nNumber format to parse a <code>C#5</code> float from string.\nNumber format for a <code>C#6</code> literal floating-point number.\nNumber format to parse a <code>C#6</code> float from string.\nNumber format for a <code>C#7</code> literal floating-point number.\nNumber format to parse a <code>C#7</code> float from string.\nNumber format for a <code>C#</code> literal floating-point number.\nNumber format to parse a <code>C#</code> float from string.\nNumber format for a <code>C++03</code> literal floating-point number.\nNumber format for a <code>C++03</code> string floating-point number.\nNumber format for a <code>C++11</code> string hexadecimal …\nNumber format for a <code>C++11</code> literal floating-point number.\nNumber format for a <code>C++11</code> string floating-point number.\nNumber format for a <code>C++14</code> string hexadecimal …\nNumber format for a <code>C++14</code> literal floating-point number.\nNumber format for a <code>C++14</code> string floating-point number.\nNumber format for a <code>C++17</code> literal hexadecimal …\nNumber format for a <code>C++17</code> string hexadecimal …\nNumber format for a <code>C++17</code> literal floating-point number.\nNumber format for a <code>C++17</code> string floating-point number.\nNumber format for a <code>C++20</code> literal hexadecimal …\nNumber format for a <code>C++20</code> string hexadecimal …\nNumber format for a <code>C++20</code> literal floating-point number.\nNumber format for a <code>C++20</code> string floating-point number.\nNumber format for a <code>C++98</code> literal floating-point number.\nNumber format for a <code>C++98</code> string floating-point number.\nNumber format for a <code>C++</code> literal hexadecimal floating-point …\nNumber format to parse a <code>C++</code> hexadecimal float from string.\nNumber format for a <code>C++</code> literal floating-point number.\nNumber format to parse a <code>C++</code> float from string.\nNumber format for a <code>C</code> literal hexadecimal floating-point …\nNumber format to parse a <code>C</code> hexadecimal float from string.\nNumber format for a C literal floating-point number.\nNumber format to parse a <code>C</code> float from string.\nMask to extract the digit separator character.\nShift to convert to and from a digit separator as a <code>u8</code>.\nNumber format for a <code>D</code> literal floating-point number.\nNumber format to parse a <code>D</code> float from string.\nNumber format for an <code>Elixir</code> literal floating-point number.\nNumber format to parse an <code>Elixir</code> float from string.\nNumber format for an <code>Elm</code> literal floating-point number.\nNumber format to parse an <code>Elm</code> float from string.\nNumber format for an <code>Erlang</code> literal floating-point number.\nNumber format to parse an <code>Erlang</code> float from string.\nMask to extract the exponent base: the base the exponent …\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nDigit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nNumber format for a <code>FORTRAN</code> literal floating-point number.\nNumber format to parse a <code>FORTRAN</code> float from string.\nMultiple consecutive fraction digit separators are allowed.\nDigit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nA digit separator is allowed after any fraction digits.\nNumber format for a <code>F#</code> literal floating-point number.\nNumber format to parse a <code>F#</code> float from string.\nNumber format for a <code>Gambit-C</code> literal floating-point number.\nNumber format to parse a <code>Gambit-C</code> float from string.\nNumber format for a <code>Golang</code> literal floating-point number.\nNumber format to parse a <code>Golang</code> float from string.\nNumber format for a <code>Guile</code> literal floating-point number.\nNumber format to parse a <code>Guile</code> float from string.\nNumber format for a <code>Haskell</code> literal floating-point number.\nNumber format to parse a <code>Haskell</code> float from string.\nMultiple consecutive integer digit separators are allowed.\nDigit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nNumber format for a <code>Javascript</code> literal floating-point …\nNumber format to parse a <code>Javascript</code> float from string.\nNumber format for a <code>Java</code> literal floating-point number.\nNumber format to parse a <code>Java</code> float from string.\nNumber format for a <code>JSON</code> literal floating-point number.\nNumber format for a <code>Julia</code> literal floating-point number.\nNumber format to parse a <code>Julia</code> float from string.\nNumber format for a <code>Julia</code> literal floating-point number.\nNumber format to parse a <code>Julia</code> float from string.\nNumber format for a <code>Kawa</code> literal floating-point number.\nNumber format to parse a <code>Kawa</code> float from string.\nNumber format for a <code>Kotlin</code> literal floating-point number.\nNumber format to parse a <code>Kotlin</code> float from string.\nA digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nNumber format for an <code>Matlab</code> literal floating-point number.\nNumber format to parse an <code>Matlab</code> float from string.\nNumber format for a <code>MongoDB</code> literal floating-point number.\nNumber format for a <code>MySQL</code> literal floating-point number.\nExponent notation is not allowed.\nExponent without a fraction component is not allowed.\nLeading zeros before a float value are not allowed.\nLeading zeros before an integer value are not allowed.\nPositive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nNo value.\nBuild number format from specifications.\nNumber format for an <code>Objective-C</code> literal floating-point …\nNumber format to parse an <code>Objective-C</code> float from string.\nNumber format for an <code>OCaml</code> literal floating-point number.\nNumber format to parse an <code>OCaml</code> float from string.\nNumber format for an <code>Octave</code> literal floating-point number.\nNumber format to parse an <code>Octave</code> float from string.\nType with the exact same size as a <code>u8</code>.\nNumber format for a <code>Perl</code> literal floating-point number.\nNumber format to parse a <code>Perl</code> float from string.\nNumber format for a <code>PHP</code> literal floating-point number.\nNumber format to parse a <code>PHP</code> float from string.\nNumber format for a <code>PostgreSQL</code> literal floating-point …\nNumber format for a <code>Python2</code> literal floating-point number.\nNumber format to parse a <code>Python2</code> float from string.\nNumber format for a <code>Python3.5</code> or lower literal …\nNumber format for a <code>Python3.6</code> or higher literal …\nNumber format for a <code>Python3</code> literal floating-point number.\nNumber format to parse a <code>Python3</code> float from string.\nNumber format for a <code>Python</code> literal floating-point number.\nNumber format to parse a <code>Python</code> float from string.\nAlias for <code>MANTISSA_RADIX</code>.\nAlias for <code>MANTISSA_RADIX_SHIFT</code>.\nNumber format for a <code>ReasonML</code> literal floating-point number.\nNumber format to parse a <code>ReasonML</code> float from string.\nAt least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nExponent notation is required.\nPositive sign before the exponent is required.\nDigits are required after the decimal point. This check …\nDigits are required before the decimal point.\nMantissa digits are required (either before or after the …\nPositive sign before the mantissa is required.\nNumber format for a <code>Ruby</code> literal floating-point number.\nNumber format for a <code>Ruby</code> literal floating-point number.\nNumber format to parse a <code>Ruby</code> float from string.\nNumber format for a <code>Rust</code> literal floating-point number.\nNumber format to parse a <code>Rust</code> float from string.\nNumber format for a <code>R</code> literal floating-point number.\nNumber format to parse a <code>R</code> float from string.\nNumber format for a <code>Sage</code> literal floating-point number.\nNumber format to parse a <code>Sage</code> float from string.\nNumber format for a <code>Scala</code> literal floating-point number.\nNumber format to parse a <code>Scala</code> float from string.\nAny digit separators are allowed in special (non-finite) …\nNumber format for a <code>SQLite</code> literal floating-point number.\nStandard number format. This is identical to the Rust …\nNumber format for a <code>Swift</code> literal floating-point number.\nNumber format to parse a <code>Swift</code> float from string.\nSome value of type <code>T</code>.\nNumber format for a <code>TOML</code> literal floating-point number.\nA digit separator is allowed after any digits.\nNumber format for a <code>Visual Basic</code> literal floating-point …\nNumber format to parse a <code>Visual Basic</code> float from string.\nNumber format for a <code>XML</code> literal floating-point number.\nNumber format for a <code>YAML</code> literal floating-point number.\nNumber format for a <code>Zig</code> literal floating-point number.\nNumber format to parse a <code>Zig</code> float from string.\nExtract the base prefix character from the format packed …\nSet the optional character for the base prefix.\nExtract the base suffix character from the format packed …\nSet the optional character for the base suffix.\nCreate number format for standard, binary number.\nCreate 128-bit, packed number format struct from builder …\nSet if base prefixes are case-sensitive.\nSet if base suffixes are case-sensitive.\nSet if exponent characters are case-sensitive.\nSet if special (non-finite) values are case-sensitive.\nSet all consecutive digit separator flags.\nCreate number format for standard, decimal number.\nExtract the digit separator from the format packed struct.\nSet the digit separator for the number format.\nSet all digit separator flag masks.\nExtract the exponent base from the format packed struct. …\nSet the radix for the exponent.\nSet if multiple consecutive exponent digit separators are …\nSet all exponent digit separator flag masks.\nSet if digit separators are allowed between exponent …\nSet if a digit separator is allowed before any exponent …\nExtract the exponent radix from the format packed struct. …\nSet the radix for exponent digits.\nSet if a digit separator is allowed after any exponent …\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nSet if multiple consecutive fraction digit separators are …\nSet all fraction digit separator flag masks.\nSet if digit separators are allowed between fraction …\nSet if a digit separator is allowed before any fraction …\nSet if a digit separator is allowed after any fraction …\nReturns the argument unchanged.\nCreate number format from radix.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the digit separator for the number format.\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet the radix for mantissa digits.\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet if digits are required after the exponent character.\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nCreate number format for standard, hexadecimal number.\nSet if multiple consecutive integer digit separators are …\nSet all integer digit separator flag masks.\nSet if digit separators are allowed between integer digits.\nSet if a digit separator is allowed before any integer …\nSet if a digit separator is allowed after any integer …\nSet all internal digit separator flags.\nCalls <code>U::from(self)</code>.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid. Digit …\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters for …\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nSet all leading digit separator flags.\nExtract the mantissa radix from the format packed struct.\nSet the radix for mantissa digits.\nCreate new <code>NumberFormatBuilder</code> with default arguments.\nSet if exponent notation is not allowed.\nSet if an exponent without fraction is not allowed.\nSet if leading zeros before a float are not allowed.\nSet if leading zeros before an integer are not allowed.\nSet if a positive sign before the exponent is not allowed.\nSet if a positive sign before the mantissa is not allowed.\nSet if special (non-finite) values are not allowed.\nCreate number format for standard, octal number.\nAlias for mantissa radix.\nExtract a generic radix from the format and bitflags.\nRe-create builder from format.\nSet if digits are required for all float components.\nSet if digits are required after the exponent character.\nSet if exponent notation is required.\nSet if a sign symbol before the exponent is required.\nSet if digits are required after the decimal point.\nSet if digits are required before the decimal point.\nSet if at least 1 significant digit is required.\nSet if a sign symbol before the mantissa is required.\nSet if any digit separators are allowed in special …\nSet all trailing digit separator flags.\nTrait to simplify creation of a <code>Bytes</code> object.\nSlice iterator that skips characters matching a given …\nIterator over a contiguous block of bytes.\nDetermine if the buffer is contiguous in memory.\nA trait for working with iterables of bytes.\nGet a ptr to the current start of the buffer.\nGet a slice to the current start of the buffer.\nGet the total number of elements in the underlying buffer.\nCreate <code>Bytes</code> from object.\nGet the current number of digits returned by the iterator.\nGet the current number of digits returned by the iterator.\nGet the current index of the iterator in the slice.\nGet the current index of the iterator in the slice.\nGet iterator over exponent digits.\nGet the next value available without consuming it.\nCheck if the next item in buffer is a given value with …\nCheck if the next element is a given value.\nCheck if the next element is a given value without case …\nGet iterator over fraction digits.\nReturns the argument unchanged.\nGet a slice to the full underlying contiguous buffer,\nIncrement the number of digits that have been returned by …\nGet iterator over integer digits.\nCalls <code>U::from(self)</code>.\nGet if no bytes are available in the buffer.\nGet if the iterator cannot return any more elements.\nDetermine if the buffer is contiguous.\nDetermine if the character is a digit.\nCreate new byte object.\nPeek the next value of the iterator, without consuming it.\nCheck if the next element is a given value with optional …\nCheck if the next element is a given value.\nCheck if the next element is a given value without case …\nRead a value of a difference type from the iterator.\nTry to read a the next four bytes as a u32.\nTry to read the next eight bytes as a u64.\nPeek the next value and consume it if the read value …\nRead a value if the value matches the provided one.\nRead a value if the value matches the provided one.\nRead a value if the value matches the provided one without …\nSet the current index of the iterator in the slice.\nSet the current index of the iterator in the slice.\nSkip zeros from the start of the iterator\nGet iterator over special floating point values.\nAdvance the internal slice by <code>N</code> elements.\nAdvance the internal slice by 1 element.\nPeek the next value of the iterator, and step only if it …\nMultiply two unsigned, integral values, and return the hi …\nMultiply two unsigned, integral values, and return the hi …\nAn interface for casting between machine scalars.\nType that can be converted to primitive with <code>as</code>.\nMask to determine if a full-carry occurred (1 in bit above …\nExponent portion of a denormal float.\nBias of the exponent.\nBitmask for the exponent, including the hidden bit.\nSize of the exponent.\nFloat information for native float types.\nBitmask for the hidden bit in exponent, which is an …\nPositive infinity as bits.\nIf the number is a signed type.\nDefines a trait that supports integral operations.\nBitmask for the mantissa (fraction), excluding the hidden …\nSize of the significand (mantissa) without hidden bit.\nMaximum exponent value in float.\nPositive infinity as bits.\nNumerical type trait.\nPrimitive type trait (which all have static lifetimes).\nBitmask for the sign bit.\nDefines a trait that supports signed integral operations.\nUnsigned type of the same size.\nDefines a trait that supports unsigned integral operations.\nAllows the high-level conversion of generic types as if <code>as</code> …\nCreates a number from another value that can be converted …\nGet the number of bits in a value.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling modulus from integer division. Not …\nGet exponent component from the float.\nReturns true if the float is a denormal.\nReturns true if the least-significant bit is even.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is infinite.\nReturns true if the float is NaN.\nReturns true if the least-significant bit is odd.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is a NaN or Infinite.\nGet mantissa (significand) component from float.\nGet the max of two finite numbers.\nGet the min of two finite numbers.\nReturns true if the float needs a negative sign when …\nGet next greater float.\nGet next greater float for a positive float. Value must be …\nGet the maximum number of digits before the slice will …\nGet previous greater float, such that …\nGet previous greater float for a positive float. Value …\nRound a positive number to even.\nShared trait for all parser options.\nShared trait for all writer options.\nGet an upper bound on the buffer size.\nDetermine if the options are valid.\nDetermine if the options are valid.\nContains the error value\nContains the success value\nA specialized Result type for lexical operations.\nGet the maximum number of digits that can be processed …\nGet the maximum number of digits that can be processed …\nCalculate the number of digits that can be processed …")